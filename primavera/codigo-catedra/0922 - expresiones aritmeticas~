#lang play

;; sintaxis abstracta
;; <expr> ::= (num <number>)
;;         |  (sum <expr> <expr>)
;;         |  (sub <expr> <expr>)
;;         |  (if0 <expr> <expr> <expr>)

;;tipo inductivo para representar expresiones aritmeticas
(deftype Expr
  (num n)
  (add l r)
  (sub l r)
  (if0 c l r))


;; calc :: Expr -> numver
;; evaluar una expresion aritmetica
(define (calc expr)
  (match expr
    [(num n) n]
    [(add l r) (+ (calc l) (calc r))]
    [(sub l r) (- (calc l) (calc r))]
    [(if0 c l r) (if (zero? (calc c))
                     (calc l)
                     (calc r))]))


;; <s-expr> ::= <number>
;;           | (list '+ <s-expr> <s-expr>)
;;           | (list '- <s-expr> <s-expr>)
;;           | (list 'if0 <s-expr> <s-expr> <s-expr>)

(define (parse s-expr)
  (match s-expr
    [n #:when (number? n) (num n)]
    [(list '+ l r) (add (parse l) (parse r))]
    [(list '- l r) (sub (parse l) (parse r))]
    [_ (error "error de parseo")])
  )

(define (run prog)
  (calc (parse prog)))